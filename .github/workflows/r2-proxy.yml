name: R2 存储代理

on:
  # 手动触发
  workflow_dispatch:
    inputs:
      action:
        description: '操作类型'
        required: true
        default: 'list'
        type: choice
        options:
          - list
          - get
          - put
          - delete
      path:
        description: '文件路径（对于 get/put/delete 操作）'
        required: false
        type: string
      content:
        description: '文件内容（对于 put 操作）'
        required: false
        type: string
      is_private:
        description: '是否为私密文件'
        required: false
        default: false
        type: boolean

  # 定时检查（可选）
  schedule:
    - cron: '0 */6 * * *' # 每6小时执行一次

jobs:
  r2-proxy:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检查输出
        id: check-output
        run: |
          echo "操作类型: ${{ github.event.inputs.action }}"
          echo "文件路径: ${{ github.event.inputs.path || 'N/A' }}"
          echo "是否为私密: ${{ github.event.inputs.is_private }}"
          
          # 设置输出变量
          echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          echo "path=${{ github.event.inputs.path || '' }}" >> $GITHUB_OUTPUT
          echo "is_private=${{ github.event.inputs.is_private }}" >> $GITHUB_OUTPUT

      - name: 设置 Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 安装依赖
        run: |
          npm install aws-sdk crypto-js

      - name: 创建 R2 代理脚本
        run: |
          cat > r2-proxy.js << 'EOF'
          const AWS = require('aws-sdk');
          const crypto = require('crypto');

          // 配置 AWS SDK
          const s3 = new AWS.S3({
            endpoint: `https://${process.env.VITE_R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
            accessKeyId: process.env.VITE_R2_ACCESS_KEY_ID,
            secretAccessKey: process.env.VITE_R2_SECRET_ACCESS_KEY,
            region: 'auto',
            signatureVersion: 'v4'
          });

          const bucketName = process.env.VITE_R2_BUCKET_NAME;
          const action = process.env.ACTION;
          const path = process.env.PATH;
          const content = process.env.CONTENT;
          const isPrivate = process.env.IS_PRIVATE === 'true';

          async function main() {
            try {
              let result;
              
              switch (action) {
                case 'list':
                  result = await listFiles();
                  break;
                case 'get':
                  result = await getFile(path);
                  break;
                case 'put':
                  result = await putFile(path, content, isPrivate);
                  break;
                case 'delete':
                  result = await deleteFile(path);
                  break;
                default:
                  throw new Error(`不支持的操作: ${action}`);
              }
              
              console.log(JSON.stringify(result));
              
            } catch (error) {
              console.error('错误:', error.message);
              process.exit(1);
            }
          }

          async function listFiles() {
            const params = {
              Bucket: bucketName,
              MaxKeys: 1000
            };
            
            const data = await s3.listObjectsV2(params).promise();
            return {
              objects: data.Contents.map(obj => ({
                key: obj.Key,
                size: obj.Size,
                lastModified: obj.LastModified,
                etag: obj.ETag
              }))
            };
          }

          async function getFile(key) {
            const params = {
              Bucket: bucketName,
              Key: key
            };
            
            const data = await s3.getObject(params).promise();
            return {
              content: data.Body.toString('utf-8'),
              contentType: data.ContentType,
              etag: data.ETag
            };
          }

          async function putFile(key, fileContent, privateFile) {
            let finalContent = fileContent;
            
            if (privateFile) {
              // 简单的加密示例（生产环境应使用更安全的方法）
              const cipher = crypto.createCipher('aes-256-cbc', 'your-secret-key');
              let encrypted = cipher.update(fileContent, 'utf8', 'hex');
              encrypted += cipher.final('hex');
              finalContent = encrypted;
            }
            
            const params = {
              Bucket: bucketName,
              Key: key,
              Body: finalContent,
              ContentType: 'text/markdown'
            };
            
            const data = await s3.putObject(params).promise();
            return {
              success: true,
              etag: data.ETag
            };
          }

          async function deleteFile(key) {
            const params = {
              Bucket: bucketName,
              Key: key
            };
            
            await s3.deleteObject(params).promise();
            return {
              success: true
            };
          }

          main();
          EOF

      - name: 执行 R2 操作
        env:
          VITE_R2_ACCOUNT_ID: ${{ secrets.VITE_R2_ACCOUNT_ID }}
          VITE_R2_ACCESS_KEY_ID: ${{ secrets.VITE_R2_ACCESS_KEY_ID }}
          VITE_R2_SECRET_ACCESS_KEY: ${{ secrets.VITE_R2_SECRET_ACCESS_KEY }}
          VITE_R2_BUCKET_NAME: ${{ secrets.VITE_R2_BUCKET_NAME }}
          ACTION: ${{ steps.check-output.outputs.action }}
          PATH: ${{ steps.check-output.outputs.path }}
          CONTENT: ${{ github.event.inputs.content || '' }}
          IS_PRIVATE: ${{ steps.check-output.outputs.is_private }}
        run: |
          node r2-proxy.js

      - name: 创建代理 API 端点
        run: |
          # 创建代理 API 端点文件
          mkdir -p api/r2
          
          cat > api/r2/[[...path]].js << 'EOF'
          // 这是一个 Next.js API 路由，用于代理 R2 请求
          // 如果你使用其他框架，可以相应调整
          
          export default async function handler(req, res) {
            const { path } = req.query;
            const { method } = req;
            
            // 设置 CORS 头
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
            res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
            
            if (method === 'OPTIONS') {
              return res.status(200).end();
            }
            
            try {
              // 这里可以调用 GitHub Actions 或直接操作 R2
              // 为了简化，这里只是示例
              res.status(200).json({ 
                message: 'R2 代理端点',
                path: path,
                method: method
              });
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          }
          EOF

      - name: 输出代理 URL
        run: |
          echo "## R2 代理已配置" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 使用方法：" >> $GITHUB_STEP_SUMMARY
          echo "1. 在环境变量中设置：\`VITE_R2_PROXY_URL=https://your-domain.com/api/r2\`" >> $GITHUB_STEP_SUMMARY
          echo "2. 或者使用 GitHub Actions 手动触发操作" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 支持的操作：" >> $GITHUB_STEP_SUMMARY
          echo "- \`list\`: 列出文件" >> $GITHUB_STEP_SUMMARY
          echo "- \`get\`: 获取文件内容" >> $GITHUB_STEP_SUMMARY
          echo "- \`put\`: 上传文件" >> $GITHUB_STEP_SUMMARY
          echo "- \`delete\`: 删除文件" >> $GITHUB_STEP_SUMMARY
